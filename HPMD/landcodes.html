<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HPMD Deer Harvest Research Tool</title>
    <script src="landcodes.js"></script>
    <script src="HarvestsByLandCodebySeasonDaySUM_Web.js"></script>
    <script src="HarvestsByLandCodebySeasonDayMEAN_Web.js"></script>
    <script src="NumberOfSeasonsPerLandcode_Web.js"></script>

    <script src="HarvestsBySexPerLandCodeBySeasonSUM_Antlers_Web.js"></script>
    <script src="HarvestsBySexPerLandCodeBySeasonSUM_NoAntlers_Web.js"></script>
    <script src="HarvestsBySexPerLandCodeBySeasonSUM_Button_Web.js"></script>
    
    <script src="HarvestsBySexPerLandCodeBySeasonDayMEAN_Antlers_Web.js"></script>
    <script src="HarvestsBySexPerLandCodeBySeasonDayMEAN_NoAntlers_Web.js"></script>
    <script src="HarvestsBySexPerLandCodeBySeasonDayMEAN_Button_Web.js"></script>

    <script src="Public Hunting Locations - Points - Data.js"></script>

    <script src="lineChart.js"></script>
    <script src="barChart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /> -->


    <!-- Load Leaflet from CDN -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
    integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
    crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
            integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
            crossorigin=""></script>

    <!-- Load Esri Leaflet from CDN -->
    <script src="https://unpkg.com/esri-leaflet@3.0.2/dist/esri-leaflet.js"
        integrity="sha512-myckXhaJsP7Q7MZva03Tfme/MSF5a6HC2xryjAM4FxPLHGqlh5VALCbywHnzs2uPoF/4G/QVXyYDDSkp5nPfig=="
        crossorigin=""></script>

    <!-- Load my content -->
    <script src="huntLocations.js"></script>
    <link rel="stylesheet" type="text/css" href="landcodes.css"/>


</head>
<body>
    <div id="headerInfo">
        <h2>Choose the area of interest and click Submit</h2>

        <p id="landCodeChooser"></p>
        <input type="button" value="Submit" onclick="getLandCodeValue()" />
    </div>

    <div>
        <p><a href="huntLocations.html" target="_blank">Full Page Map</a></p>
    </div>
    <div id="mapid">
        <div id="basemaps-wrapper" class="leaflet-bar">
            <select id="basemaps">
                <option value="OpenStreetMap">Open Street Map</option>
                <option value="Topographic">Topographic</option>
                <option value="Streets">Streets</option>
                <option value="Imagery">Imagery</option>
                <option value="ImageryClarity">Imagery (Clarity)</option>
            </select>
        </div>
    </div>
    

    <div>
        <h2 id="focusArea"></h2>
        <p id="seasonsOfData"></p>
        <p id="harvestData"></p>
    </div>
    <div>
        <h3>Total Deer Harvest by Sex by Season</h3>
        <canvas id="landCodeHarvestChartSexBarSum" width="1000" height="300" style="border:1px solid"></canvas>
    </div>
    <div>
        <h3>Mean Deer Harvest by Sex by Season Day</h3>
        <canvas id="landCodeHarvestChartSexLineMean" width="1000" height="300" style="border:1px solid"></canvas>
    </div>
    <div>
        <h3>Total Deer Harvest by Season Day</h3>
        <canvas id="landCodeHarvestChartSum" width="1000" height="300" style="border:1px solid"></canvas>
    </div>
    <!-- <div>
        <h3>Mean Deer Harvest by Season Day</h3>
        <canvas id="landCodeHarvestChartMean" width="1000" height="300" style="border:1px solid"></canvas>
    </div> -->



    <script>
        // Learned that this code has to follow the element being acted on, can't be before the element is declared.

        // MAP SECTION
        function onLocationFound(e) {
            var radius = e.accuracy;

            L.marker(e.latlng).addTo(map)
                .bindPopup("You are within " + radius + " meters from this point").openPopup();

            L.circle(e.latlng, radius).addTo(map);
        }

        function onLocationError(e) {
            alert(e.message);
        }

        const urlEvaluator = (url, text) => url ? text : "Nothing";
        const defaultPointLocation = [39.23, -77];
        const defaultZoom = 8;
        let map = L.map('mapid').setView(defaultPointLocation, defaultZoom);

        map.locate({setView: true, maxZoom: 16});
        map.on('locationfound', onLocationFound);
        map.on('locationerror', onLocationError);

        let osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'});
        osmLayer.addTo(map)

        let layerLabels; // see js file

        L.geoJSON(huntingSpotsGeojson, {
            pointToLayer: function (feature, latlng) {
                let markerStyle = {
                    // fillColor: getColor(feature.properties.Type), // TODO: Adapt this to BowOnly 
                    fillColor: "#FF8200",
                    color: "#252525",
                    fillOpacity: 0.9,
                    opacity: 0.8,
                    weight: 1,
                    radius: 8
                };

                return L.circleMarker(latlng, markerStyle);
            },
            onEachFeature: function (feature, osmLayer) {
                // console.log(urlEvaluator(feature.properties.URL1, "Link 1"))
                osmLayer.bindPopup(
                    '<h1>' + feature.properties.GuideName1 + '</h1>' +
                    '<h4>' + feature.properties.GuideName2 + '</h4>' +
                    '<p>' + feature.properties.Information + '</p>' +
                    // '<p>COUNTY: ' + feature.properties.County + '</p>' +
                    '<h3>LAND CODE(s): ' + feature.properties.LandCode + '</h3>' +
                    '<h4><a href=' + feature.properties.URL1 + ' target="_blank">' + urlEvaluator(feature.properties.URL1, "Link 1") + '</href></h4>' +
                    '<h4><a href=' + feature.properties.URL2 + ' target="_blank">' + urlEvaluator(feature.properties.URL2, "Link 2") + '</href></h4>' +
                    '<h4><a href=' + feature.properties.URL_MAP + ' target="_blank">' + urlEvaluator(feature.properties.URL_MAP, "Map") + '</href></h4> '
                );
            }
          }).addTo(map)

        document
            .querySelector('#basemaps')
            .addEventListener('change', function (e) {
                  let basemap = e.target.value;
                  setBasemap(basemap);
                      }
                  );
        
        let huntSpotFeatures = huntingSpotsGeojson["features"]
        let huntSpotInventory = {}
        for (let i = 0; i < huntSpotFeatures.length; i++) {
            let properties = huntSpotFeatures[i]["properties"];
            let code = properties["LandCode"];

            if (!code) {
                continue;
            }
            else {
                
                let lat = properties["Latitude"];
                let long = properties["Longitude"];
                
                // When the locations codes are xxx;xxx they need to be split apart for map zoom to work with drop down
                let codeArray = code.split(";")
                for (let i = 0; i < codeArray.length; i++){
                    huntSpotInventory[codeArray[i]] = [lat, long]
                }               
            }
            
        }

        // Build the choices for the drop down list from the landcodes json
        let text = "<select id='landCodeDropDown'>"
        for (let i = 0; i < landCodes.length; i++) {
            let obj = landCodes[i]
            let name = obj["Name"]
            let code = obj["LandCode"]
            text += `<option value=${code}>` + `${code} - ${name}`
        }
        text += "</select>"
        document.getElementById("landCodeChooser").innerHTML = text;
        
        // Setup for the chart and retrieving data given the json object ordering issue I encountered
        let anyUsefulLandCodeDataSeasonDay = seasonDayHarvestsSum[Object.keys(seasonDayHarvestsSum)[0]]
        let genericSeasonDayArraySorted = Object.keys(anyUsefulLandCodeDataSeasonDay).sort(function(a, b){return a-b})
        
        let anyUsefulLandCodeDataSexSeasons = seasonsHarvestsSexAntlersSum[Object.keys(seasonsHarvestsSexAntlersSum)[0]]
        let genericSeasonsArraySorted = Object.keys(anyUsefulLandCodeDataSexSeasons) //.sort(function(a, b){return a-b}); // In firefox it sorts backwards!!

        // Need a function to change the chart to use the most current user choice after the user hits submit
        let harvestLineChartSum = new Chart(document.getElementById('landCodeHarvestChartSum'), createLineConfig(data={}, titleText="Total Deer Harvest by Season Day"),displayLegend=false); // Needs to be in namespace before function acts on it
        // let harvestLineChartMean = new Chart(document.getElementById('landCodeHarvestChartMean'), createLineConfig(data={}, titleText="Mean Deer Harvest by Season Day"),displayLegend=false); // Needs to be in namespace before function acts on it
        let harvestBarChartSexSum = new Chart(document.getElementById('landCodeHarvestChartSexBarSum'), createBarConfig(data={}, titleText="Total Deer Harvest by Sex by Season")); // Needs to be in namespace before function acts on it
        let harvestLineChartSexMean = new Chart(document.getElementById('landCodeHarvestChartSexLineMean'), createLineConfig(data={}, titleText="Mean Deer Harvest by Sex by Season Day")); // Needs to be in namespace before function acts on it

        function updatePageWithUserChosenCode(fullChoiceText, landCodeValue) {
            // TODO: Break this function into many smaller focussed functions

            // document.getElementById("focusArea").innerHTML = `${fullChoiceText}`;

            //Testing purposes
            //document.getElementById("harvestData").innerHTML = JSON.stringify(seasonDayHarvestsSum[landCodeValue]);

            // Getting the number of seasons of data and setting element values
            let seasonCountObj;
            let numSeasons;
            let minSeason;
            let maxSeason;
            const colorFemaleAntlerlessMale = "#ff5393";
            const colorMale = "#2986cc";
            const colorButtonbuck = "#9fc5e8";

            // Number of seasons of data for land code of interest
            try {
                seasonCountObj = numberSeasonsPerLandcode[landCodeValue]
                numSeasons = seasonCountObj["SeasonsCount"]
                minSeason = seasonCountObj["SeasonMin"].replace("_", "/")
                maxSeason = seasonCountObj["SeasonMax"].replace("_", "/")
            } catch (TypeError) {
                numSeasons = 0;
                minSeasons = 0;
                maxSeasons = 0;
            }
            finally {                
                document.getElementById("seasonsOfData").innerHTML = `${numSeasons} seasons of data. (${minSeason} to ${maxSeason})`;
            }


            // Single-Line Chart Based on Season Day
            let labelsSeasonDay = genericSeasonDayArraySorted; // ASSESS: why do this reassignment??

            let harvestsSumSeasonDay = [];
            let harvestsMeanSeasonDay = [];

            let dataOfInterestSumSeasonDay = seasonDayHarvestsSum[landCodeValue];
            let dataOfInterestMeanSeasonDay = seasonDayHarvestsMean[landCodeValue];

            for (let i = 0; i < genericSeasonDayArraySorted.length; i++) {

                // ASSESS: Does this looping need handling? The breaks will interfere without proper push when undefined????

                // Total Harvests
                let harvestCountSumSeasonDay;
                try {
                    harvestCountSumSeasonDay = dataOfInterestSumSeasonDay[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // alert(`No Sum Data for ${fullChoiceText}`)
                    // break;
                }
                
                harvestsSumSeasonDay.push(harvestCountSumSeasonDay);
                
                // Mean Harvests
                // let harvestCountMeanSeasonDay;
                // try {
                //     harvestCountMeanSeasonDay = dataOfInterestMeanSeasonDay[genericSeasonDayArraySorted[i]]
                // } catch (TypeError) {
                //     // Handle situation where new area code is in options but no data exists yet
                //     // alert(`No Mean Data for ${fullChoiceText}`)
                //     // break;
                // }
                // harvestsMeanSeasonDay.push(harvestCountMeanSeasonDay);
            }
            
            // Total Harvests by Season Day by Landcode, Line Chart
            let graphDataObjSum = assembleLineDataObj(labels=labelsSeasonDay, labelText="Sum: ", graphData=harvestsSumSeasonDay, border=colorOptions[0])
            let configSum = createLineConfig(data=graphDataObjSum, titleText="Total Deer Harvest by Season Day", displayLegend=false)
            
            if (typeof harvestLineChartSum !== 'undefined' || harvestLineChartSum != null) {
                harvestLineChartSum.destroy();
            }
            harvestLineChartSum = new Chart(
                document.getElementById('landCodeHarvestChartSum'),
                configSum,
              );
            
            // Mean Harvest by Season Day by Landcode, Line Chart
            // let graphDataObjMean = assembleLineDataObj(labels=labelsSeasonDay, labelText="Mean: ", graphData=harvestsMeanSeasonDay, border=colorOptions[1])
            // let configMean = createLineConfig(data=graphDataObjMean, titleText="Mean Deer Harvest by Season Day", displayLegend=false)

            // if (typeof harvestLineChartMean !== 'undefined' || harvestLineChartMean != null) {
            //     harvestLineChartMean.destroy();
            // }
            // harvestLineChartMean = new Chart(
            //     document.getElementById('landCodeHarvestChartMean'),
            //     configMean
            //   );

            // Total Harvests by Sex by Season, Stacked Bar Chart
            let labelsSeasons = genericSeasonsArraySorted.map(item => item.replace('_','/'));
            let dataBarAntler = [];
            let dataBarNoAntler = [];
            let dataBarButtonbuck = [];

            let seasonsButtonbuckObjBar = seasonsHarvestsSexButtonSum[landCodeValue]
            let seasonsAntlerObjBar = seasonsHarvestsSexAntlersSum[landCodeValue]
            let seasonsNoAntlerObjBar = seasonsHarvestsSexNoAntlersSum[landCodeValue]

            for (let i = 0; i < genericSeasonsArraySorted.length; i++) {
                let seasonFocus = genericSeasonsArraySorted[i]

                try {
                    dataBarAntler.push(seasonsAntlerObjBar[seasonFocus])
                } catch {
                    dataBarAntler.push(0)
                }
                try {
                    dataBarNoAntler.push(seasonsNoAntlerObjBar[seasonFocus])
                } catch {
                    dataBarNoAntler.push(0)
                }
                try {
                    dataBarButtonbuck.push(seasonsButtonbuckObjBar[seasonFocus])
                } catch {
                    dataBarButtonbuck.push(0)
                }
                
            }

            let barChartDatasetsArray = [{
                    label: 'Female or Antlerless Male',
                    data: dataBarNoAntler,
                    backgroundColor: colorFemaleAntlerlessMale,
                    },
                    {
                    label: 'Male',
                    data: dataBarAntler,
                    backgroundColor: colorMale,
                    },
                    {
                    label: 'Buttonbuck',
                    data: dataBarButtonbuck,
                    backgroundColor: colorButtonbuck,
                    },]

            let dataSexBar = assembleBarDataObj(labels=labelsSeasons, dataSetsArray=barChartDatasetsArray)

            const configSexBar = createBarConfig(data=dataSexBar, titleText='Total Deer Harvest by Sex by Season')

            if (typeof harvestBarChartSexSum !== 'undefined' || harvestBarChartSexSum != null) {
                harvestBarChartSexSum.destroy();
            }
            harvestBarChartSexSum = new Chart(
                document.getElementById('landCodeHarvestChartSexBarSum'),
                configSexBar,
              );

            // Mean Harvests by Sex by Season day, Multi Line Chart
            // May need try/catch on these
            let dataOfInterestMeanSeasonDaySexButton = seasonsHarvestsSexButtonMean[landCodeValue];
            let dataOfInterestMeanSeasonDaySexAntler = seasonsHarvestsSexAntlersMean[landCodeValue];
            let dataOfInterestMeanSeasonDaySexNoAntler = seasonsHarvestsSexNoAntlersMean[landCodeValue];

            let harvestsSexMeanSeasonDayButton = [];
            let harvestsSexMeanSeasonDayAntler = [];
            let harvestsSexMeanSeasonDayNoAntler = [];

            for (let i = 0; i < genericSeasonDayArraySorted.length; i++) {
                // let message;
                 // Mean Harvests Sex
                // BUTTON BUCK
                let harvestCountMeanSexSeasonDayButton;
                try {
                    harvestCountMeanSexSeasonDayButton = dataOfInterestMeanSeasonDaySexButton[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Sex (Button) Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Button) Data for ${fullChoiceText}`)
                    // break;
                }
                if (harvestCountMeanSexSeasonDayButton) {
                    harvestsSexMeanSeasonDayButton.push(harvestCountMeanSexSeasonDayButton);
                } else {
                    harvestsSexMeanSeasonDayButton.push(0)
                }
                
                // ANTLERS
                let harvestCountMeanSexSeasonDayAntler;
                try {
                    harvestCountMeanSexSeasonDayAntler = dataOfInterestMeanSeasonDaySexAntler[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Sex (Antler) Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Antler) Data for ${fullChoiceText}`)
                    // break;
                }
                if (harvestCountMeanSexSeasonDayAntler) {
                    harvestsSexMeanSeasonDayAntler.push(harvestCountMeanSexSeasonDayAntler);
                } else {
                    harvestsSexMeanSeasonDayAntler.push(0)
                }
                
                // NO ANTLERS
                let harvestCountMeanSexSeasonDayNoAntler;
                try {
                    harvestCountMeanSexSeasonDayNoAntler = dataOfInterestMeanSeasonDaySexNoAntler[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Sex (No Antler) Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (No Antler) Data for ${fullChoiceText}`)
                    // break;
                }
                if (harvestCountMeanSexSeasonDayNoAntler) {
                    harvestsSexMeanSeasonDayNoAntler.push(harvestCountMeanSexSeasonDayNoAntler);
                } else {
                    harvestsSexMeanSeasonDayNoAntler.push(0)
                }
                
                // alert(message)
            }
            let graphDataObjSexMean = {
                    labels: labelsSeasonDay,
                    datasets: [
                        {
                            label: "Buttonbuck",
                            data: harvestsSexMeanSeasonDayButton,
                            fill: false,
                            // borderColor: 'rgb(75, 192, 192)',
                            borderColor: colorButtonbuck,
                            tension: 0.1
                        },
                        {
                            label: "Male",
                            data: harvestsSexMeanSeasonDayAntler,
                            fill: false,
                            // borderColor: 'rgb(75, 192, 192)',
                            borderColor: colorMale,
                            tension: 0.1 
                        },
                        {
                            label: "Female or Antlerless Male",
                            data: harvestsSexMeanSeasonDayNoAntler,
                            fill: false,
                            // borderColor: 'rgb(75, 192, 192)',
                            borderColor: colorFemaleAntlerlessMale,
                            tension: 0.1 
                        }
                    ]
                };

            // let graphDataObjSexMean = assembleLineDataObj(labels=labelsSeasonDay, labelText="Mean: ", graphData=harvestsMeanSeasonDay, border=colorOptions[1])
            let configSexMean = createLineConfig(data=graphDataObjSexMean, titleText="Mean Deer Harvest by Sex by Season Day")

            if (typeof harvestLineChartSexMean !== 'undefined' || harvestLineChartSexMean != null) {
                harvestLineChartSexMean.destroy();
            }
            harvestLineChartSexMean = new Chart(
                document.getElementById('landCodeHarvestChartSexLineMean'),
                configSexMean
              );


            // Zoom map to point corresponding to user choice in dropdown list
            let locationArray = huntSpotInventory[landCodeValue];
            zoomLevel = 13;
            if (!locationArray) {
                locationArray = defaultPointLocation;
                zoomLevel = defaultZoom;
            }
            map.setView(locationArray, zoomLevel, {animation: true});
            
        }

        // Need function to get the users choice of land code from the drop down and manipulate dynamic elements
        function getLandCodeValue() {
            let dropDownElement = document.getElementById("landCodeDropDown");
            let selectedText = dropDownElement.options[dropDownElement.selectedIndex].innerHTML;
            let selectedValue = dropDownElement.value;
            updatePageWithUserChosenCode(selectedText, selectedValue)
        }


    </script>

</body>
</html>