<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HPMD Deer Harvest Research Tool</title>
    <script src="landcodes.js"></script>
    <!-- <script src="HarvestsByLandCodebySeasonDaySUM_Web.js"></script> -->

    <script src="HarvestsByLandCodebySeasonDayMEAN_Web.js"></script>
    <script src="HarvestsByLandCodebySeasonDayMIN_Web.js"></script>
    <script src="HarvestsByLandCodebySeasonDayMAX_Web.js"></script>

    <script src="NumberOfSeasonsPerLandcode_Web.js"></script>

    <script src="HarvestsBySexPerLandCodeBySeasonSUM_Antlers_Web.js"></script>
    <script src="HarvestsBySexPerLandCodeBySeasonSUM_NoAntlers_Web.js"></script>
    <script src="HarvestsBySexPerLandCodeBySeasonSUM_Button_Web.js"></script>
    
    <script src="HarvestsBySexPerLandCodeBySeasonDayMEAN_Antlers_Web.js"></script>
    <script src="HarvestsBySexPerLandCodeBySeasonDayMEAN_NoAntlers_Web.js"></script>
    <script src="HarvestsBySexPerLandCodeBySeasonDayMEAN_Button_Web.js"></script>

    <script src="ReservationsByLandCodebySeasonDayMAX_Web.js"></script>
    <script src="ReservationsByLandCodebySeasonDayMEAN_Web.js"></script>
    <script src="ReservationsByLandCodebySeasonDayMIN_Web.js"></script>

    <script src="Public Hunting Locations - Points - Data.js"></script>

    <script src="lineChart.js"></script>
    <script src="barChart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /> -->


    <!-- Load Leaflet from CDN -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
        integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
        crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
            integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
            crossorigin=""></script>

    <!-- Load Esri Leaflet from CDN -->
    <script src="https://unpkg.com/esri-leaflet@3.0.2/dist/esri-leaflet.js"
        integrity="sha512-myckXhaJsP7Q7MZva03Tfme/MSF5a6HC2xryjAM4FxPLHGqlh5VALCbywHnzs2uPoF/4G/QVXyYDDSkp5nPfig=="
        crossorigin=""></script>

    <!-- Load my content -->
    <!-- <script src="huntLocations.js"></script> -->
    <link rel="stylesheet" type="text/css" href="landcodes.css"/>


</head>
<body>
    <div id="headerInfo">
        <h2>Choose the area of interest and click Submit</h2>

        <p id="landCodeChooser"></p>
        <input type="button" value="Submit" onclick="getLandCodeValue()" />
    </div>

    <div>
        <p><a href="huntLocations.html" target="_blank">Full Page Map</a></p>
    </div>
    <div id="mapid">
        <div id="basemaps-wrapper" class="leaflet-bar">
            <select id="basemaps">
                <option value="OpenStreetMap">Open Street Map</option>
                <option value="Topographic">Topographic</option>
                <option value="Streets">Streets</option>
                <option value="Imagery">Imagery</option>
                <option value="ImageryClarity">Imagery (Clarity)</option>
            </select>
        </div>
    </div>
    

    <div>
        <h2 id="focusArea"></h2>
        <p id="seasonsOfData"></p>
        <p id="harvestData"></p>
    </div>

    <button type="button" class="collapsible">Total Deer Harvest by Sex by Season</button>
    <div class="content">
        <!-- <h3>Total Deer Harvest by Sex by Season</h3> -->
        <canvas id="landCodeHarvestChartSexBarSum" width="1000" height="300" style="border:1px solid"></canvas>
    </div>
    
    <button type="button" class="collapsible">Mean Deer Harvest by Sex by Season Day</button>
    <div class="content">
        <!-- <h3>Mean Deer Harvest by Sex by Season Day</h3> -->
        <canvas id="landCodeHarvestChartSexLineMean" width="1000" height="300" style="border:1px solid"></canvas>
    </div>

    <!-- <div>
        <h3>Total Deer Harvest by Season Day</h3>
        <canvas id="landCodeHarvestChartSum" width="1000" height="300" style="border:1px solid"></canvas>
    </div> -->

    <button type="button" class="collapsible">Mean/Min/Max Deer Harvest by Season Day</button>
    <div class="content">
        <!-- <h3>Mean/Min/Max Deer Harvest by Season Day</h3> -->
        <canvas id="landCodeHarvestChartMeanMinMax" width="1000" height="300" style="border:1px solid"></canvas>
    </div>

    <button type="button" class="collapsible">Mean/Min/Max Reservations by Season Day (Where Applicable)</button>
    <div class="content">
        <!-- <h3>Mean/Min/Max Reservations by Season Day (Where Applicable)</h3> -->
        <canvas id="landCodeReservationsChartMeanMinMax" width="1000" height="300" style="border:1px solid"></canvas>
    </div>



    <script>
        // Learned that this code has to follow the element being acted on, can't be before the element is declared.

        // MAP SECTION
        function setBasemap (basemap) {
            if (layer) {
            map.removeLayer(layer);
            }

            if (basemap === "OpenStreetMap") {
                layer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                })
            } else {
                layer = L.esri.basemapLayer(basemap);
            }
            // layer = L.esri.basemapLayer(basemap);

            map.addLayer(layer);

            // Label Controls
            if (layerLabels) {
            map.removeLayer(layerLabels);
            }

            if (
            basemap === 'ShadedRelief'
            ) {
                layerLabels = L.esri.basemapLayer(basemap + 'Labels');
                map.addLayer(layerLabels);
            } else if (basemap.includes('Imagery')) {
                layerLabels = L.esri.basemapLayer('ImageryLabels');
                map.addLayer(layerLabels);
            } else if (basemap.includes("OpenStreetMap")) {
                false
            }
        }

        function onLocationFound(e) {
            var radius = e.accuracy;

            L.marker(e.latlng).addTo(map)
                .bindPopup("You are within " + radius + " meters from this point").openPopup();

            L.circle(e.latlng, radius).addTo(map);
        }

        function onLocationError(e) {
            alert(e.message);
        }

        // Straight from W3 Schools https://www.w3schools.com/howto/tryit.asp?filename=tryhow_js_collapsible
        var coll = document.getElementsByClassName("collapsible");
        var i;
        for (i = 0; i < coll.length; i++) {
            coll[i].addEventListener("click", function() {
                this.classList.toggle("active");
                var content = this.nextElementSibling;
                if (content.style.display === "block") {
                content.style.display = "none";
                } else {
                content.style.display = "block";
                }
            });
        }


        const urlEvaluator = (url, text) => url ? text : "Nothing";
        const defaultPointLocation = [39.23, -77];
        const defaultZoom = 8;
        let map = L.map('mapid').setView(defaultPointLocation, defaultZoom);

        map.locate({setView: true, maxZoom: 16});
        map.on('locationfound', onLocationFound);
        map.on('locationerror', onLocationError);

        let layer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'});
        layer.addTo(map)

        let layerLabels; // see js file

        L.geoJSON(huntingSpotsGeojson, {
            pointToLayer: function (feature, latlng) {
                let markerStyle = {
                    // fillColor: getColor(feature.properties.Type), // TODO: Adapt this to BowOnly 
                    fillColor: "#FF8200",
                    color: feature.properties.BowOnlyOption == "Yes" ?  "#ffffff" : "#252525",
                    fillOpacity: 0.9,
                    opacity: 0.8,
                    weight: 1,
                    radius: 8
                };

                return L.circleMarker(latlng, markerStyle);
            },
            onEachFeature: function (feature, layer) {
                // console.log(urlEvaluator(feature.properties.URL1, "Link 1"))
                layer.bindPopup(
                    '<h1>' + feature.properties.GuideName1 + '</h1>' +
                    '<h4>' + feature.properties.GuideName2 + '</h4>' +
                    '<p>' + feature.properties.Information + '</p>' +
                    // '<p>COUNTY: ' + feature.properties.County + '</p>' +
                    '<h3>LAND CODE(s): ' + feature.properties.LandCode + '</h3>' +
                    '<h4><a href=' + feature.properties.URL1 + ' target="_blank">' + urlEvaluator(feature.properties.URL1, "Link 1") + '</href></h4>' +
                    '<h4><a href=' + feature.properties.URL2 + ' target="_blank">' + urlEvaluator(feature.properties.URL2, "Link 2") + '</href></h4>' +
                    '<h4><a href=' + feature.properties.URL_MAP + ' target="_blank">' + urlEvaluator(feature.properties.URL_MAP, "Map") + '</href></h4> '
                );
            }
          }).addTo(map)

        document
            .querySelector('#basemaps')
            .addEventListener('change', function (e) {
                  let basemap = e.target.value;
                  setBasemap(basemap);
                      }
                  );
        
        let huntSpotFeatures = huntingSpotsGeojson["features"]
        let huntSpotInventory = {}
        for (let i = 0; i < huntSpotFeatures.length; i++) {
            let properties = huntSpotFeatures[i]["properties"];
            let code = properties["LandCode"];

            if (!code) {
                continue;
            }
            else {
                
                let lat = properties["Latitude"];
                let long = properties["Longitude"];
                
                // When the locations codes are xxx;xxx they need to be split apart for map zoom to work with drop down
                let codeArray = code.split(";")
                for (let i = 0; i < codeArray.length; i++){
                    huntSpotInventory[codeArray[i]] = [lat, long]
                }               
            }
            
        }

        // Build the choices for the drop down list, from the landcodes json
        let text = "<select id='landCodeDropDown'>"
        for (let i = 0; i < landCodes.length; i++) {
            let obj = landCodes[i]
            let name = obj["Name"]
            let code = obj["LandCode"]
            text += `<option value=${code}>` + `${code} - ${name}`
        }
        text += "</select>"
        document.getElementById("landCodeChooser").innerHTML = text;
        
        // Setup for the chart and retrieving data given the json object ordering issue I encountered
        // let anyUsefulLandCodeDataSeasonDay = seasonDayHarvestsSum[Object.keys(seasonDayHarvestsSum)[0]]
        let anyUsefulLandCodeDataSeasonDay = seasonDayHarvestsMin[Object.keys(seasonDayHarvestsMin)[0]]
        let genericSeasonDayArraySorted = Object.keys(anyUsefulLandCodeDataSeasonDay).sort(function(a, b){return a-b})
        
        let anyUsefulLandCodeDataSexSeasons = seasonsHarvestsSexAntlersSum[Object.keys(seasonsHarvestsSexAntlersSum)[0]]
        let genericSeasonsArraySorted = Object.keys(anyUsefulLandCodeDataSexSeasons) //.sort(function(a, b){return a-b}); // In firefox it sorts backwards!!

        // Need a function to change the chart to use the most current user choice after the user hits submit
        // let harvestLineChartSum = new Chart(document.getElementById('landCodeHarvestChartSum'), createLineConfig(data={}, titleText="Total Deer Harvest by Season Day"),displayLegend=false); // Needs to be in namespace before function acts on it
        let harvestLineChartMeanMinMax = new Chart(document.getElementById('landCodeHarvestChartMeanMinMax'), createLineConfig(data={}, titleText="Mean/Min/Max Deer Harvest by Season Day"), displayLegend=false); // Needs to be in namespace before function acts on it
        let harvestBarChartSexSum = new Chart(document.getElementById('landCodeHarvestChartSexBarSum'), createBarConfig(data={}, titleText="Total Deer Harvest by Sex by Season")); // Needs to be in namespace before function acts on it
        let harvestLineChartSexMean = new Chart(document.getElementById('landCodeHarvestChartSexLineMean'), createLineConfig(data={}, titleText="Mean Deer Harvest by Sex by Season Day")); // Needs to be in namespace before function acts on it
        let reservationsLineChartMeanMinMax = new Chart(document.getElementById('landCodeReservationsChartMeanMinMax'), createLineConfig(data={}, titleText="Mean/Min/Max Hunter Reservations by Season Day"), displayLegend=false); // Needs to be in namespace before function acts on it

        function updatePageWithUserChosenCode(fullChoiceText, landCodeValue) {
            // TODO: Break this function into many smaller focussed functions

            // document.getElementById("focusArea").innerHTML = `${fullChoiceText}`;

            //Testing purposes
            //document.getElementById("harvestData").innerHTML = JSON.stringify(seasonDayHarvestsSum[landCodeValue]);

            // Getting the number of seasons of data and setting element values
            let seasonCountObj;
            let numSeasons;
            let minSeason;
            let maxSeason;
            const colorFemaleAntlerlessMale = "#ff5393";
            const colorMale = "#2986cc";
            const colorButtonbuck = "#9fc5e8";

            // Number of seasons of data for land code of interest
            try {
                seasonCountObj = numberSeasonsPerLandcode[landCodeValue]
                numSeasons = seasonCountObj["SeasonsCount"]
                minSeason = seasonCountObj["SeasonMin"].replace("_", "/")
                maxSeason = seasonCountObj["SeasonMax"].replace("_", "/")
            } catch (TypeError) {
                numSeasons = 0;
                minSeasons = 0;
                maxSeasons = 0;
            }
            finally {                
                document.getElementById("seasonsOfData").innerHTML = `*Mean values based on ${numSeasons} seasons of data.`// (${minSeason} to ${maxSeason})`;
            }


            // Single-Line Chart Based on Season Day
            let labelsSeasonDay = genericSeasonDayArraySorted; // ASSESS: why do this reassignment??

            // let harvestsSumSeasonDay = [];
            // let harvestsMeanSeasonDay = [];

            // let dataOfInterestSumSeasonDay = seasonDayHarvestsSum[landCodeValue];
            // let dataOfInterestHarvestsMeanSeasonDay = seasonDayHarvestsMean[landCodeValue];

            // for (let i = 0; i < genericSeasonDayArraySorted.length; i++) {

                // ASSESS: Does this looping need handling? The breaks will interfere without proper push when undefined????

                // Total Harvests
                // let harvestCountSumSeasonDay;
                // try {
                //     harvestCountSumSeasonDay = dataOfInterestSumSeasonDay[genericSeasonDayArraySorted[i]]
                // } catch (TypeError) {
                //     // Handle situation where new area code is in options but no data exists yet
                //     // alert(`No Sum Data for ${fullChoiceText}`)
                //     // break;
                // }
                
                // harvestsSumSeasonDay.push(harvestCountSumSeasonDay);
                
                // Mean Harvests
                // let harvestCountMeanSeasonDay;
                // try {
                //     harvestCountMeanSeasonDay = dataOfInterestHarvestsMeanSeasonDay[genericSeasonDayArraySorted[i]]
                // } catch (TypeError) {
                //     // Handle situation where new area code is in options but no data exists yet
                //     // alert(`No Mean Data for ${fullChoiceText}`)
                //     // break;
                // }
                // harvestsMeanSeasonDay.push(harvestCountMeanSeasonDay);
            // }
            
            // Total Harvests by Season Day by Landcode, Line Chart
            // let graphDataObjSum = assembleLineDataObj(labels=labelsSeasonDay, labelText="Sum: ", graphData=harvestsSumSeasonDay, border=colorOptions[0])
            // let configSum = createLineConfig(data=graphDataObjSum, titleText="Total Deer Harvest by Season Day", displayLegend=false)
            
            // if (typeof harvestLineChartSum !== 'undefined' || harvestLineChartSum != null) {
            //     harvestLineChartSum.destroy();
            // }
            // harvestLineChartSum = new Chart(
            //     document.getElementById('landCodeHarvestChartSum'),
            //     configSum,
            //   );

            // Total Harvests by Sex by Season, Stacked Bar Chart
            let labelsSeasons = genericSeasonsArraySorted.map(item => item.replace('_','/'));
            let dataBarAntler = [];
            let dataBarNoAntler = [];
            let dataBarButtonbuck = [];

            let seasonsButtonbuckObjBar = seasonsHarvestsSexButtonSum[landCodeValue]
            let seasonsAntlerObjBar = seasonsHarvestsSexAntlersSum[landCodeValue]
            let seasonsNoAntlerObjBar = seasonsHarvestsSexNoAntlersSum[landCodeValue]

            for (let i = 0; i < genericSeasonsArraySorted.length; i++) {
                let seasonFocus = genericSeasonsArraySorted[i]

                try {
                    dataBarAntler.push(seasonsAntlerObjBar[seasonFocus])
                } catch {
                    dataBarAntler.push(0)
                }
                try {
                    dataBarNoAntler.push(seasonsNoAntlerObjBar[seasonFocus])
                } catch {
                    dataBarNoAntler.push(0)
                }
                try {
                    dataBarButtonbuck.push(seasonsButtonbuckObjBar[seasonFocus])
                } catch {
                    dataBarButtonbuck.push(0)
                }
                
            }

            let barChartDatasetsArray = [{
                    label: 'Female or Antlerless Male',
                    data: dataBarNoAntler,
                    backgroundColor: colorFemaleAntlerlessMale,
                    },
                    {
                    label: 'Male',
                    data: dataBarAntler,
                    backgroundColor: colorMale,
                    },
                    {
                    label: 'Buttonbuck',
                    data: dataBarButtonbuck,
                    backgroundColor: colorButtonbuck,
                    },]

            let dataSexBar = assembleBarDataObj(labels=labelsSeasons, dataSetsArray=barChartDatasetsArray)

            const configSexBar = createBarConfig(data=dataSexBar, titleText='Total Deer Harvest by Sex by Season')

            if (typeof harvestBarChartSexSum !== 'undefined' || harvestBarChartSexSum != null) {
                harvestBarChartSexSum.destroy();
            }
            harvestBarChartSexSum = new Chart(
                document.getElementById('landCodeHarvestChartSexBarSum'),
                configSexBar,
              );

            // Mean Harvests by Sex by Season day, Multi Line Chart
            // May need try/catch on these
            let dataOfInterestMeanSeasonDaySexButton = seasonsHarvestsSexButtonMean[landCodeValue];
            let dataOfInterestMeanSeasonDaySexAntler = seasonsHarvestsSexAntlersMean[landCodeValue];
            let dataOfInterestMeanSeasonDaySexNoAntler = seasonsHarvestsSexNoAntlersMean[landCodeValue];

            let harvestsSexMeanSeasonDayButton = [];
            let harvestsSexMeanSeasonDayAntler = [];
            let harvestsSexMeanSeasonDayNoAntler = [];

            for (let i = 0; i < genericSeasonDayArraySorted.length; i++) {

                // Mean Harvests Sex
                // BUTTON BUCK
                let harvestCountMeanSeasonDay;
                try {
                    harvestCountMeanSeasonDay = dataOfInterestMeanSeasonDaySexButton[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Sex (Button) Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Button) Data for ${fullChoiceText}`)
                    // break;
                }
                if (harvestCountMeanSeasonDay) {
                    harvestsSexMeanSeasonDayButton.push(harvestCountMeanSeasonDay);
                } else {
                    harvestsSexMeanSeasonDayButton.push(0)
                }
                
                // ANTLERS
                let harvestCountMeanSexSeasonDayAntler;
                try {
                    harvestCountMeanSexSeasonDayAntler = dataOfInterestMeanSeasonDaySexAntler[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Sex (Antler) Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Antler) Data for ${fullChoiceText}`)
                    // break;
                }
                if (harvestCountMeanSexSeasonDayAntler) {
                    harvestsSexMeanSeasonDayAntler.push(harvestCountMeanSexSeasonDayAntler);
                } else {
                    harvestsSexMeanSeasonDayAntler.push(0)
                }
                
                // NO ANTLERS
                let harvestCountMeanSexSeasonDayNoAntler;
                try {
                    harvestCountMeanSexSeasonDayNoAntler = dataOfInterestMeanSeasonDaySexNoAntler[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Sex (No Antler) Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (No Antler) Data for ${fullChoiceText}`)
                    // break;
                }
                if (harvestCountMeanSexSeasonDayNoAntler) {
                    harvestsSexMeanSeasonDayNoAntler.push(harvestCountMeanSexSeasonDayNoAntler);
                } else {
                    harvestsSexMeanSeasonDayNoAntler.push(0)
                }
            }
            let graphDataObjSexMean = {
                    labels: labelsSeasonDay,
                    datasets: [
                        {
                            label: "Buttonbuck",
                            data: harvestsSexMeanSeasonDayButton,
                            fill: false,
                            // borderColor: 'rgb(75, 192, 192)',
                            borderColor: colorButtonbuck,
                            tension: 0.1
                        },
                        {
                            label: "Male",
                            data: harvestsSexMeanSeasonDayAntler,
                            fill: false,
                            // borderColor: 'rgb(75, 192, 192)',
                            borderColor: colorMale,
                            tension: 0.1 
                        },
                        {
                            label: "Female or Antlerless Male",
                            data: harvestsSexMeanSeasonDayNoAntler,
                            fill: false,
                            // borderColor: 'rgb(75, 192, 192)',
                            borderColor: colorFemaleAntlerlessMale,
                            tension: 0.1 
                        }
                    ]
                };

            let configSexMean = createLineConfig(data=graphDataObjSexMean, titleText="Mean Deer Harvest by Sex by Season Day")

            if (typeof harvestLineChartSexMean !== 'undefined' || harvestLineChartSexMean != null) {
                harvestLineChartSexMean.destroy();
            }
            harvestLineChartSexMean = new Chart(
                document.getElementById('landCodeHarvestChartSexLineMean'),
                configSexMean
              );
            
            
            // Mean/Min/Max Harvest by Season Day by Landcode, Line Chart

            let dataOfInterestHarvestsMeanSeasonDay = seasonDayHarvestsMean[landCodeValue];
            let dataOfInterestHarvestsMinSeasonDay = seasonDayHarvestsMin[landCodeValue];
            let dataOfInterestHarvestsMaxSeasonDay = seasonDayHarvestsMax[landCodeValue];

            let harvestsMeanSeasonDay = [];
            let harvestsMinSeasonDay = [];
            let harvestsMaxSeasonDay = [];

            for (let i = 0; i < genericSeasonDayArraySorted.length; i++) {

                // Mean Harvests
                let harvestCountMeanSeasonDay;
                try {
                    harvestCountMeanSeasonDay = dataOfInterestHarvestsMeanSeasonDay[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Button) Data for ${fullChoiceText}`)
                    // break;
                }
                if (harvestCountMeanSeasonDay) {
                    harvestsMeanSeasonDay.push(harvestCountMeanSeasonDay);
                } else {
                    harvestsMeanSeasonDay.push(0)
                }

                // Min Harvests
                let harvestCountMinSeasonDay;
                try {
                    harvestCountMinSeasonDay = dataOfInterestHarvestsMinSeasonDay[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Button) Data for ${fullChoiceText}`)
                    // break;
                }
                if (harvestCountMinSeasonDay) {
                    harvestsMinSeasonDay.push(harvestCountMinSeasonDay);
                } else {
                    harvestsMinSeasonDay.push(0)
                }

                // Max Harvests
                let harvestCountMaxSeasonDay;
                try {
                    harvestCountMaxSeasonDay = dataOfInterestHarvestsMaxSeasonDay[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Button) Data for ${fullChoiceText}`)
                    // break;
                }
                if (harvestCountMaxSeasonDay) {
                    harvestsMaxSeasonDay.push(harvestCountMaxSeasonDay);
                } else {
                    harvestsMaxSeasonDay.push(0)
                }
            }

            let graphDataObjHarvestsMeanMinMax = {
                    labels: labelsSeasonDay,
                    datasets: [
                        
                        {
                            label: "Mean",
                            data: harvestsMeanSeasonDay,
                            fill: false,
                            // borderColor: 'rgb(75, 192, 192)',
                            borderColor: "black",
                            // tension: 0.1
                        },
                        {
                            label: "Min",
                            data: harvestsMinSeasonDay,
                            fill: false,
                            // borderColor: "rgba(255, 255, 0, 0.8)"
                            // backgroundColor: "rgba(255, 255, 0, 0.5)",
                            // hidden: true,
                            // borderColor: 'rgb(75, 192, 192)',
                            // borderColor: "grey",
                            // tension: 0.1 
                        },
                        {
                            label: "Max",
                            data: harvestsMaxSeasonDay,
                            fill: "-1",
                            backgroundColor: "rgba(255, 130, 0, 0.8)",
                            // borderColor: "rgba(255, 255, 0, 0.8)"
                            // borderColor: 'rgb(75, 192, 192)',
                            // borderColor: "grey",
                            // tension: 0.1 
                        },

                    ]
                };
            // let graphDataObjHarvestsMeanMinMax = assembleLineDataObj(labels=labelsSeasonDay, labelText="Mean: ", graphData=harvestsMeanSeasonDay, border=colorOptions[1])
            let configHarvestsMeanMinMax = createLineConfig(data=graphDataObjHarvestsMeanMinMax, titleText="Mean/Min/Max Deer Harvest by Season Day", displayLegend=false)
            


            if (typeof harvestLineChartMeanMinMax !== 'undefined' || harvestLineChartMeanMinMax != null) {
                harvestLineChartMeanMinMax.destroy();
            }
            harvestLineChartMeanMinMax = new Chart(
                document.getElementById('landCodeHarvestChartMeanMinMax'),
                configHarvestsMeanMinMax
              );
              
            // Mean/Min/Max Reservations by Season Day by Landcode, Line Chart
            let dataOfInterestReservationsMeanSeasonDay = seasonDayReservationsMean[landCodeValue];
            let dataOfInterestReservationsMinSeasonDay = seasonDayReservationsMin[landCodeValue];
            let dataOfInterestReservationsMaxSeasonDay = seasonDayReservationsMax[landCodeValue];

            let reservationsMeanSeasonDay = [];
            let reservationsMinSeasonDay = [];
            let reservationsMaxSeasonDay = [];

            for (let i = 0; i < genericSeasonDayArraySorted.length; i++) {

                // Mean Reservations
                let reservationsCountMeanSeasonDay;
                try {
                    reservationsCountMeanSeasonDay = dataOfInterestReservationsMeanSeasonDay[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Button) Data for ${fullChoiceText}`)
                    // break;
                }
                if (reservationsCountMeanSeasonDay) {
                    reservationsMeanSeasonDay.push(reservationsCountMeanSeasonDay);
                } else {
                    reservationsMeanSeasonDay.push(0)
                }

                // Min Harvests
                let reservationsCountMinSeasonDay;
                try {
                    reservationsCountMinSeasonDay = dataOfInterestReservationsMinSeasonDay[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Button) Data for ${fullChoiceText}`)
                    // break;
                }
                if (reservationsCountMinSeasonDay) {
                    reservationsMinSeasonDay.push(reservationsCountMinSeasonDay);
                } else {
                    reservationsMinSeasonDay.push(0)
                }

                // Max Harvests
                let reservationsCountMaxSeasonDay;
                try {
                    reservationsCountMaxSeasonDay = dataOfInterestReservationsMaxSeasonDay[genericSeasonDayArraySorted[i]]
                } catch (TypeError) {
                    // Handle situation where new area code is in options but no data exists yet
                    // message = `${message}. No Mean Data for ${fullChoiceText}`
                    // alert(`No Mean Sex (Button) Data for ${fullChoiceText}`)
                    // break;
                }
                if (reservationsCountMaxSeasonDay) {
                    reservationsMaxSeasonDay.push(reservationsCountMaxSeasonDay);
                } else {
                    reservationsMaxSeasonDay.push(0)
                }
            };

            let graphDataObjReservationsMeanMinMax = {
                    labels: labelsSeasonDay,
                    datasets: [
                        
                        {
                            label: "Mean",
                            data: reservationsMeanSeasonDay,
                            fill: false,
                            // borderColor: 'rgb(75, 192, 192)',
                            borderColor: "black",
                            // tension: 0.1
                        },
                        {
                            label: "Min",
                            data: reservationsMinSeasonDay,
                            fill: false,
                            // borderColor: "rgba(255, 255, 0, 0.8)"
                            // backgroundColor: "rgba(255, 255, 0, 0.5)",
                            // hidden: true,
                            // borderColor: 'rgb(75, 192, 192)',
                            // borderColor: "grey",
                            // tension: 0.1 
                        },
                        {
                            label: "Max",
                            data: reservationsMaxSeasonDay,
                            fill: "-1",
                            backgroundColor: "rgb(98,167,108, 0.8)",
                            // borderColor: "rgba(255, 255, 0, 0.8)"
                            // borderColor: 'rgb(75, 192, 192)',
                            // borderColor: "grey",
                            // tension: 0.1 
                        },

                    ]
                };
            
            let configReservationsMeanMinMax = createLineConfig(data=graphDataObjReservationsMeanMinMax, titleText="Mean/Min/Max Hunter Reservations by Season Day", displayLegend=false);

            if (typeof reservationsLineChartMeanMinMax !== 'undefined' || reservationsLineChartMeanMinMax != null) {
                reservationsLineChartMeanMinMax.destroy();
            }
            reservationsLineChartMeanMinMax = new Chart(
                document.getElementById('landCodeReservationsChartMeanMinMax'),
                configReservationsMeanMinMax
              );


            // Zoom map to point corresponding to user choice in dropdown list
            let locationArray = huntSpotInventory[landCodeValue];
            zoomLevel = 13;
            if (!locationArray) {
                locationArray = defaultPointLocation;
                zoomLevel = defaultZoom;
            }
            map.setView(locationArray, zoomLevel, {animation: true});            
        }

        // Need function to get the users choice of land code from the drop down and manipulate dynamic elements
        function getLandCodeValue() {
            let dropDownElement = document.getElementById("landCodeDropDown");
            let selectedText = dropDownElement.options[dropDownElement.selectedIndex].innerHTML;
            let selectedValue = dropDownElement.value;
            updatePageWithUserChosenCode(selectedText, selectedValue)
        }


    </script>

</body>
<footer class="footer">
    &copy; Copyright 2022 RAM Mapping<br>
</footer>
</html>